---
title: "Exercise Worksheet (Chapter 6)"
author: "Dan Maxwell"
date: "June 1, 2017"
output:
  pdf_document: default
  html_document: default
header-includes: \usepackage{color}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r init, echo = FALSE, warning = FALSE, message = FALSE}

library(sqldf)
library(dplyr)

```

## Introduction
Review the section notes for *R in Action* before working on the challenges.

> ### *Ref: R in Action (Section 6.1.1)* 
> As Kabacoff does not discuss the `table()` function here, you'll want to read
> about it in section 7.2.1 (pages 145 & 146). 

> ### *Ref: R in Action (Section 6.5.1)* 
> The `~` in the formula `mpg ~ cyl` separates the *dependent* or *response*
> variable on the left from the *independent* (*explanatory* or *predictor*)
> variable on the right.  Please note: statistics textbookss are inconsistent in
> the names they use for these two variables.    
>
> Here's a definition of these two kinds of variables, provided by Gravetter &
> Wellnau (2016).  "The *dependent variable* is the one that is observed to assess
> the effect of the treatment ... while the *independent variable* is the one
> manipulated by the researcher" (p. 15).  
>
> In Listing 6.9, Kabacoff introduces the `*` operator. What does that mean? To
> answer this question, see table 8.2 (p. 172) for a list of symbols used in R
> formulas and their respective definitions. \newline


### The Barplot Challenge

```{r barplot}

survey <- read.csv("informatics_survey.csv", stringsAsFactors = FALSE)

# What happens if we don't set the stringsAsFactors argument?
q <- data.frame(survey$Q5_1, stringsAsFactors = FALSE)

colnames(q) <- c("response")

# Remove the rows with empty responses.
q <- subset(q, response != "")
q <- q[q$response != "",]

cnts <- table(q)

# Save the original graph parameters.
opar <- par(no.readonly = TRUE)

# Adjust graph margin parameters.
par(mai = c(.5, 1.5, .5, .5))

# What does the las argument do?  Look it up with ?par().
barplot(cnts, 
        horiz = TRUE, 
        col   = 'lightblue',
        las   = 2,
        main  = "Knowledge of Statistics - Question 5.1",
        cex.names = 0.5)

par(opar)

```
Data Source: *2017 UF Informatics Survey*

## The Grouped & Stacked Barplot Challenge

```{r group_barplot}

crime <- read.csv("drink_crime.csv", stringsAsFactors = FALSE)

# Data must be presented as a matrix or vector for stacked or grouped barplots.

barplot(as.matrix(crime[, c(2:4)]), 
        legend = crime[, 1],
           col = c("lightcoral","lightblue","khaki","beige"))

barplot(as.matrix(crime[, c(2:4)]), 
        legend = crime[, 1],
           col = c("lightcoral","lightblue","khaki","lightgreen"),
   args.legend = list(x = "topleft"),
        beside = TRUE)

# Here's another way to create the barplots by creating a new dataframe.
lgnd        <- crime$Crime
binge       <- crime$Binge
occassional <- crime$Occasional
never       <- crime$Never
cnts        <- data.frame(binge, occassional, never)

barplot(as.matrix(cnts),
        legend = lgnd,
        col = c("lightcoral","lightblue","khaki","beige"))

barplot(as.matrix(cnts),
        legend = lgnd,
           col = c("lightcoral","lightblue","khaki","lightgreen"),
   args.legend = list(x = "topleft"),
        beside = TRUE )

```
Data Source: *Statistical Methods and Data Analysis* (p. 110)


## The Pie Chart Challenge

Code for the pie chart challenge:

```{r pie}
survey <- read.csv("informatics_survey.csv", stringsAsFactors = FALSE)

# INSTRUCTOR NOTE 
# sqldf does not work when running under R version 3.4.0.  The two commands below
# return an error message that the survey table cannot be found, though it was
# created above.  As of 06.26.17, sqldf requires R version 3.3.3 but will work with
# warnings under 3.3.2.

# You can write a select statement with new column names. 
tmp <- sqldf("select q3 as department, count(q3) as total from survey where q3 != ' ' group by q3")

# Or, you can execute a simple select and rename the variables afterwards.
tmp <- sqldf("select q3, count(q3) from survey where q3 != ' ' group by q3")

# Rename the columns -- department & department count.
colnames(tmp)  <- c("dept","dept_cnt")

# Add new column for academic group (HUM Humanities, SCI Sciences, SOC, Social Sciences, MED Medical)
tmp$acad_grp <- ""                       

# Set the new acad_grp column, using fix().  What happens if you use edit()?
# fix(tmp)                                   

# Save a backup copy of the modified dataframe.
write.csv(tmp, file = "temp.csv")          

# Create a new dataframe of the two columns needed for the pie chart. 
temp   <- data.frame(tmp$acad_grp, tmp$dept_cnt, stringsAsFactors = FALSE)

colnames(temp) <- c("acad_grp","dept_cnt")

temp <- read.csv("informatics_acad_grp.csv", stringsAsFactors = FALSE)

grp_by <- group_by(temp, acad_grp)                    # Group rows by academic group.

slices <- summarize(grp_by, grp_tot = sum(dept_cnt))  # Sum dept_cnt for each academic group.

# Assign descriptive labels to the slices.
slices$acad_grp[1] <- "Humanities"
slices$acad_grp[2] <- "Health Sciences"
slices$acad_grp[3] <- "Sciences"
slices$acad_grp[4] <- "Social Sciences"
slices$acad_grp[5] <- "Unknown"

# Calculate percentages, round to two digits, and then create labels.
slices$grp_pct <- (slices$grp_tot / sum(slices$grp_tot))
slices$grp_pct <- round(slices$grp_pct, 2) * 100
slices$lbl     <- paste(slices$acad_grp, " ", slices$grp_pct, "%", sep = "")

pie(slices$grp_tot, labels = slices$lbl, main = "Pie Chart") 

# INSTRUCTOR NOTE
# This code accomplishes the same thing with the pipe operator.  If you have
# time to demo this in lab, uncomment and test.

# slices <- group_by(temp, acad_grp) %>% summarize(grp_tot = sum(dept_cnt))
# pie(slices$grp_tot, labels = slices$acad_grp, main = "Pie Chart (Pipe)") 

```
Data Source: *2017 UF Informatics Survey*


## The histogram challenge

Code for the histogram challenge:

```{r histogram}

opar <- par(no.readonly = TRUE)

own <- read.delim("home_ownership.txt", sep = "\t", stringsAsFactors = FALSE)

hist(own$pct_1985, 
     main = "1985", 
     col  = "lightblue",
     ylim = c(0, 27),
     xlab = "Home Ownership %")

hist(own$pct_1996, 
     main = "1996", 
     col  = "lightblue",
     ylim = c(0, 27),
     xlab = "Home Ownership %")

hist(own$pct_2002, 
     main = "2002", 
     col  = "lightblue",
     ylim = c(0, 27),
     xlab = "Home Ownership %")

par(opar)

```
Data Source: *Statistical Methods and Data Analysis* (p. 129)

## The box plot challenge

Code for the box plot challenge:

```{r boxplot}

own <- read.delim("home_ownership.txt", sep = "\t", stringsAsFactors = FALSE)

boxplot(own$pct_1985, 
        own$pct_1996, 
        own$pct_2002, 
        notch = TRUE,
        ylab  = "Home Ownership %",
        main  = "Home Ownership in the United States",
        names = c("1985","1996","2002"))

```
Data Source: *Statistical Methods and Data Analysis* (p. 129)

## The scatter plot challenge

Code for the scatter plot challenge:

```{r scatterplot}

money <- read.delim("money_supply.txt", sep = "\t", stringsAsFactors = FALSE)

plot(money$m2, money$m3, xlab = "M2 (Trillions)", ylab = "M3 (Trillions)")

# Now, fit a regression model and plot the line.
fit <- lm(money$m3 ~ money$m2, data = money)

abline(fit, col = "blue")

```
Data Source: *Statistical Methods and Data Analysis* (p. 137)


## The stem-and-leaf Challenge

Code for the stem-and-leaf challenge:

```{r stemleaf}

ozone <- read.csv("ozone.csv", stringsAsFactors = FALSE)

x <- ozone[c(0:79),]

# The scale argument must equal 2 or the function only prints even numbers.
stem(x, scale = 2) 

```
Data Source: *Statistical Methods and Data Analysis* (p. 77)


#### References

Gravetter, F. J. (2015). *Statistics for the behavioral sciences* (10th ed.). Boston, MA: Cengage Learning.

